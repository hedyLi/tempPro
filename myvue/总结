·使用less需要步骤：
  a.页面style中配置lang='less'
  b.安装cnpm install less less-loader --save-dev 
  【需要重启打开 npm run dev】
  
·elementUI的使用
  a. main.js中引入
   //import element-ui相关
	 import ElementUI from 'element-ui';
     import 'element-ui/lib/theme-chalk/index.css';
		
	 Vue.use(ElementUI);
	 
·vue中无法解析ico图标
 修改build/webpack.base.conf.js   test: /\.(png|jpe?g|gif|svg|ico)(\?.*)?$/,
 
 
·vue中父传子 传递 对象数组 ，接收时：
子： breadlist:{
				type:Array,
				default:()=>[],
				required:true
			}
父： <Breadcrumb :breadlist="breadlist" ></Breadcrumb> 

       
·百度地图使用:http://lbsyun.baidu.com/index.php?title=jspopular3.0/guide/getkey
  
   或者百度搜索 ：  百度开发人员手册...
   
 四个步骤：第一步注册百度账号，第二步申请成为百度开发者，第三步获取服务密钥（ak）,第四步使用相关服务 

问题解决： console提出警告：A parser-blocking, cross site (i.e. different eTLD+1) script,

   把api引用url里面的 api 改为 getscript
<script src="http://api.map.baidu.com/api?v=2.0&ak=你申请的ak"></script>
api 改为 getscript以后
<script src="http://api.map.baidu.com/getscript?v=2.0&ak=你申请的ak"></script>

·二维码使用
  cnpm install qrcode --save-dev
  
  
·接口数据模拟综合
 1.配置config下index.js
	 proxyTable:{
 			//connect-mock-middleware工具使用
	  	'/api':{
	  		target:'http://127.0.0.1:3721',
	  		changeOrigin:true,
	  		secure:false
	  	}
     }
  2.编写接口文件mock>post>api_product_recommend.js
  3.snail mock工具使用	
    3.1安装snail-cline
       cnpm install -g snail-cline
    3.2开启snail mock
                 执行 snail mock
                 执行成功后，就会显示第一步配置的地址。

·使用vuex状态管理
    安装vuex  cnpm install Vuex --save
    在src创建store文件夹，存放vuex代码
  在main.js中引入vuex代码文件，然后在new vue里引用

  state:数据
  mutations：方法的集合                           
  actions： 这里面定义的方法复杂从后端获取数据                                                          
                                  
                         4、  backend api(actions去请求的后端api接口)       
                                  |
                                  |  
                                  |
        2、 组件调用dispatch方法   |        6、使用commit 将数据给mutations
          |————————————————————》3、5、actions ————————————》
          |                                             |
          |                                             |
          |                                             |
          |                                             |
 1、 vue component(组件)                           7、  mutations
          |                                             |
          |                                             |
          |《———————————————— 8、 state  ——————————————  |
                                     mutations定义的方法就会去修改state里的数据   
           state的数据修改了，组件就可以使用了

1、login.vue 点击登录，根据返回值（success/error）判断是否执行vuex 将用户信息进行全局存储
2、如果success 就使用this.$store.commit()方法执行vuex的mutations中定义的方法
将数据进行存储(因为浏览器刷新会重置vuex对象，所有需要将用户信息顺便存到sessionStorge中)
2.1、main.js 使用router.beforeEach方法，这个方法作业是在每个页面跳转之前判断 进入这个页面是否需要用户登录
3、在router.js 对需要用户登录才能进入的页面添加一个字段
{
    	path:'/product',
    	name:'product',
      component:Product,
      meta:{requireAuth:true}//添加了这个字段，表示进入这个路由之前都要验证
}

前进刷新后退不刷新功能
router文件的index中给需要的缓存不刷新的路由做一个配置，其中的keepAlive就是设置是否缓存这个组件视图
{
      path:'/Login',
      name:'login',
      component:Login,
      meta:{
        keepAlive:true 
      }
    }
在App.vue中渲染试图的router-view做一些判断 v-if="$route.meta.keepAlive"
<keep-alive>是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。
<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。

    <keep-alive>
      <router-view v-if="$route.meta.keepAlive"></router-view>
    </keep-alive>
    <router-view v-if="!$route.meta.keepAlive"></router-view>
   
   
   
   
   
   
   
   
   
   
   
   